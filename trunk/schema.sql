/* USERS TABLE

   The name field is VARCHAR(200) because the primary key must be unique,
   and MYSQL can only index a finite number of characters.

   Passwords are hashed so evildoers who gain access to the database cannot see
   your password (finding another password with the same hash is very hard.)

   The random salt is combined with your password before hashing, so two users 
   with the same password will not have the same password hash. This also makes
   dictionary attacks harder: the attacker has to guess passwords for each user
   separately because the users have different salts.
*/

DROP TABLE IF EXISTS users;
CREATE TABLE users (
  name VARCHAR(200) PRIMARY KEY,
  password_hash TEXT NOT NULL,
  password_salt TEXT NOT NULL
);

DROP PROCEDURE IF EXISTS create_user;
CREATE PROCEDURE
  create_user (IN the_name VARCHAR(200), IN the_hash TEXT, IN the_salt TEXT)
BEGIN
  INSERT INTO users (name, password_hash, password_salt)
    VALUES (the_name, the_hash, the_salt);
END;

/* Get the user's password hash and salt to check an incoming password. */
DROP PROCEDURE IF EXISTS read_user;
CREATE PROCEDURE
  read_user (IN the_name VARCHAR(200))
BEGIN
  SELECT * FROM users WHERE name = the_name;
END;

/* Updating a user changes the user's password.
   This procedure cannot be used to change the username. */
DROP PROCEDURE IF EXISTS update_user;
CREATE PROCEDURE
  update_user (IN the_name VARCHAR(200), IN the_hash TEXT, IN the_salt TEXT)
BEGIN
  UPDATE users 
    SET password_hash = the_hash, password_salt = the_salt 
    WHERE name = the_name;
END;

/* Delete a user and all of the user's saved games. */
DROP PROCEDURE IF EXISTS delete_user;
CREATE PROCEDURE 
  delete_user (IN the_name VARCHAR(200))
BEGIN
  START TRANSACTION;
  DELETE FROM saves WHERE username = the_name;
  DELETE FROM users WHERE name = the_name;
  COMMIT;
END; 


/* SAVES TABLE 

   Id is used to choose saves from a list. It can also be used to sort saves
   by the order in which they were created, which may be different from the
   order of their timestamps if we allow users to overwrite save "slots".

   Username is the primary key to the users table. It is required to list 
   all saves from a particular user.

   Description is an optional label supplied by the user or generated by
   the client-side code.

   State is XML code representing the game at the moment it was saved.

   Time_stamp is automatically updated when a save is created or updated.
*/

DROP TABLE IF EXISTS saves;
CREATE TABLE saves (
  id INT AUTO_INCREMENT PRIMARY KEY,
  username VARCHAR(200),
  description TEXT,
  state TEXT NOT NULL,
  time_stamp TIMESTAMP
);

DROP PROCEDURE IF EXISTS create_save;
CREATE PROCEDURE
  create_save (IN the_name VARCHAR(200), IN the_desc TEXT, IN the_state TEXT)
BEGIN
  INSERT INTO saves (username, description, state)
    VALUES (the_name, the_desc, the_state);
END;

/* Before reading a save, we need to get the save id from a list of saves
   created by the current user. This list also shows the description of
   each save and a time stamp to help the user choose a save. */
DROP PROCEDURE IF EXISTS read_save_list;
CREATE PROCEDURE
  read_save_list (IN the_name VARCHAR(200))
BEGIN
  SELECT id, description, UNIX_TIMESTAMP(time_stamp) AS time_stamp
    FROM saves WHERE username = the_name;
END;

DROP PROCEDURE IF EXISTS read_save;
CREATE PROCEDURE
  read_save (IN the_id INT)
BEGIN
  SELECT * FROM saves WHERE id = the_id;
END;

/* Updating a save replaces a saved game with another saved game,
   preserving the username and save id. We only need this procedure
   if we allow users to overwrite specific save "slots". */
DROP PROCEDURE IF EXISTS update_save;
CREATE PROCEDURE
  update_save (IN the_id INT, IN the_desc TEXT, IN the_state TEXT)
BEGIN
  UPDATE saves
    SET description = the_desc, state = the_state
    WHERE id = the_id;
END;

DROP PROCEDURE IF EXISTS delete_save;
CREATE PROCEDURE
  delete_save (IN the_id INT)
BEGIN
  DELETE FROM saves WHERE id = the_id;
END;

